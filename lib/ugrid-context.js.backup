'use strict';

var util = require('util');
var stream = require('stream');

var UgridClient = require('./ugrid-client.js');
var ugrid = require('./ugrid-array.js');
var Lines = require('./lines.js');

module.exports = UgridContext;

util.inherits(UgridContext, UgridClient);

function UgridContext(arg) {
	if (!(this instanceof UgridContext))
		return new UgridContext(arg);
	var self = this, worker = this.worker = [];

	arg = arg || {};
	arg.data = arg.data || {};
	arg.data.type = 'master';
	UgridClient.call(this, arg);
	var inBrowser = (typeof window != 'undefined');
	var streamId = 0;
	var maxWorker = process.env.UGRID_MAX_WORKER;

	this.started = this.ended = false;
	this.jobId = 0;
	this.jobs = {};
	this.streams = {};
	this.firstData = {};
	this.contextId = Date.now();

	this.once('connect', function(data) {
		var i;
		if (!maxWorker || maxWorker > data.devices.length)
			maxWorker = data.devices.length;
		for (i = 0; i < maxWorker; i++) {
			self.worker.push(new Worker(data.devices[i]));
			self.firstData[data.devices[i].uuid] = data.devices;
		}
		self.started = true;
		// XXXX: the following line is a bad workaround. Fix mem leaks instead of forcing exit
		if (!inBrowser) process.on('exit', this.end);
	});

	this.on('workerError', function workerError(msg) {
		console.error('Error from worker id %d:', msg.from);
		console.error(msg.args);
	});

	this.on('remoteClose', function getWorkerClose() {
		throw 'Fatal error: unexpected worker exit';
	});

	this.getWorkers = function (callback) {
		if (self.started) return callback();
		this.once('connect', function() {callback();});
	};

	function Worker(w) {
		this.uuid = w.uuid;
		this.id = w.id;
		this.ip = w.ip;
		this.ntask = 0;
	}

	Worker.prototype.rpc = function (cmd, args, done) {
		self.request({uuid: this.uuid, id: this.id}, {cmd: cmd, args: args}, done);
	};

	Worker.prototype.send = function (cmd, args) {
		self.send(this.uuid, {cmd: cmd, args: args});
	};

	this.on('request', function (msg) { // Protocol to handle stream flow control: reply when data is consumed
		if (msg.data.cmd == 'stream') {
			self.emit(msg.data.stream, msg.data.data, function() {
				try {self.reply(msg);} catch(err) {}
			});
		}
	});

	this.on('startStream', function (msg) {
		var job = self.jobs[msg.jobid];
		job.streamsToLaunch[msg.streamid].startStream();
	});

	this.end = function () {
		if (self.ended) return;
		self.ended = true;
		if (this.started) self.set({complete: 1});
		self._end();
	};

	this.datasetIdCounter = 0;	// global dataset id counter

	this.parallelize = function(localArray, nPartitions) {return new ugrid.Parallelize(this, localArray, nPartitions);}
	this.textFile = function(file, nPartitions) {return new ugrid.TextFile(this, file, nPartitions);}
	this.lineStream = function(stream, config) {return new ugrid.Stream(this, stream, 'line', config);}
	this.objectStream = function(stream, config) {return new ugrid.Stream(this, stream, 'object', config);}	

	this.runTask = function(task, callback) {
		function getLeastBusyWorkerId(preferredLocation) {
			var wid, ntask;
			for (var i = 0; i < self.worker.length; i++) {
				if ((ntask == undefined) || (ntask > self.worker[i].ntask)) {
					ntask = self.worker[i].ntask;
					wid = i;
				}
			}
			return wid;
		}

		function serialize(obj) {
			return JSON.stringify(obj,function(key, value) {
				return (typeof value === 'function' ) ? value.toString() : value;
			});
		}

		var wid = getLeastBusyWorkerId(task.nodes[task.rddid].getPreferedLocation(task.pid));
		this.worker[wid].ntask++;
		rpc('runTask', wid, serialize(task), this.contextId, function(err, res) {
			self.worker[wid].ntask--;
			callback(err, res);
		});
	}

	this.runJob = function(opt, root, action, callback) {
		var jobId = this.jobId++;
		var stream = opt._stream ||Â new this.createReadStream(jobId, opt);	// user redable stream instance

		this.getWorkers(function () {
			findShuffleStages(function(shuffleStages) {
				if (shuffleStages.length == 0) runResultStage();
				else {
					var cnt = 0;
					function shuffleDone() {
						if (++cnt < shuffleStages.length) runShuffleStage(shuffleStages[cnt], shuffleDone);
						else runResultStage();
					}
					runShuffleStage(shuffleStages[cnt], shuffleDone);
				}
			});
		});

		function runShuffleStage(stage, done) {
			findNodes(stage, function(nodes) {
				var pid = 0, shuffleTasks = [], cnt = 0;
				stage.shufflePartitions = [];

				for (var i = 0; i < stage.dependencies.length; i++)
					for (var j = 0; j < stage.dependencies[i].partitions.length; j++)
						stage.shufflePartitions[pid++] = new ugrid.Partition(stage.id, pid, stage.dependencies[i].id, 
							stage.dependencies[i].partitions[j].partitionIndex);

				for (var i = 0; i < stage.shufflePartitions.length; i++)
					shuffleTasks.push(new Task(self.contextId, jobId, nodes, stage.id, i));

				for (var i = 0; i < shuffleTasks.length; i++)
					self.runTask(shuffleTasks[i], function (err, res) {
						stage.shufflePartitions[res.pid].files = res.files;
						if (++cnt < shuffleTasks.length) return;
						stage.executed = true;
						done();
					});
			});
		}

		function runResultStage() {
			findNodes(root, function(nodes) {
				var tasks = [];
				for (var i = 0; i < root.partitions.length; i++)
					tasks.push(new Task(self.contextId, jobId, nodes, root.id, i, action));
				callback({id: jobId, contextId: self.contextId, stream: stream}, tasks);
			});
		}

		function findNodes(node, done) {
			var nodes = {};
			interruptibleTreewalk(node, function cin(n, done) {
				done(n.shuffling && n.executed);
			}, function cout(n, done) {
				n.getPartitions(function() {
					if (nodes[n.id] == undefined) nodes[n.id] = n;
					done();
				});
			}, function() {done(nodes)});
		}

		function findShuffleStages(callback) {
			var stages = [];
			interruptibleTreewalk(root, function cin(n, done) {
				if (n.shuffling && !n.executed) stages.unshift(n);
				done(n.shuffling && n.executed); 	// stage boundary are shuffle nodes
			}, function cout(n, done) {done();}, function() {callback(stages);});
		}

		function interruptibleTreewalk(n, cin, cout, done) {
			cin(n, function(uturn) { // if uturn equals true the subtree under node won't be treewalked
				if (!uturn) {
					var nDependencies = 0;
					for (var i = 0; i < n.dependencies.length; i++)
						interruptibleTreewalk(n.dependencies[i], cin, cout, function() {
							if (++nDependencies == n.dependencies.length) cout(n, done);
						});
					if (n.dependencies.length == 0) cout(n, done);
				} else cout(n, done);
			});
		}

		return stream;
	}

	function rpc(cmd, workerNum, args, contextId, callback) {
		self.request(self.worker[workerNum], {cmd: cmd, args: args, master_uuid: self.uuid, contextId: contextId, worker: self.worker}, callback);
	}
}

function Task(contextId, jobId, nodes, rddid, pid, action) {
	this.id = jobId;
	this.rddid = rddid;
	this.pid = pid;
	this.nodes = nodes;
	this.contextId = contextId;
	this.action = action;
	this.files = {};			// objet dans lequel nous allons stocker les informations sur les fichiers de shuffle

	this.load = function(dep) {
		for (var n in this.nodes)
			for (var d in dep) this.nodes[n][d] = dep[d];
	}

	this.run = function(done) {
		var pipeline = [], self = this;
		var mm = this.nodes[this.rddid].mm;
		var fs = this.nodes[this.rddid].fs;
		var action = this.action;
		var p = this.pid;
		var tmpPart = action ? this.nodes[this.rddid].partitions[p] : this.nodes[this.rddid].shufflePartitions[p];
		var tmpRDD = this.nodes[tmpPart.RDDId];
		var blocksToRegister = [];

		if (action)
			pipeline.push({transform: function aggregate(context, data) {
				for (var i = 0; i < data.length; i++)
					action.init = action.src(action.init, data[i]);
			}});

		do {
			var tmpPartAvailable = mm.isAvailable(tmpPart);							// is partition available in memory
			if (!tmpPartAvailable && tmpRDD.persistent)	{							// if data must be stored in memory
				if ((action != undefined) || (tmpRDD.id != this.rddid)) { 			// no persist if no action and shuffleRDD
					blocksToRegister.push(tmpPart);									// register block inside memory manager
					pipeline.unshift(tmpPart);										// add it to pipeline
				}
			}
			if (tmpPartAvailable || (tmpPart.parentRDDId == undefined)) break;		// source partition found
			pipeline.unshift(tmpRDD);												// else add current rdd transform to pipeline
			tmpPart = this.nodes[tmpPart.parentRDDId].partitions[tmpPart.parentPartitionIndex];
			tmpRDD = this.nodes[tmpPart.RDDId];
		} while (1);

		if (tmpPartAvailable) mm.partitions[tmpPart.RDDId + '.' + tmpPart.partitionIndex].iterate(this, tmpPart.partitionIndex, pipeline, iterateDone);
		else this.nodes[tmpPart.RDDId].iterate(this, tmpPart.partitionIndex, pipeline, iterateDone);

		function iterateDone() {
			blocksToRegister.map(function(block) {mm.register(block)});
			if (action) done({data: action.init});
			else self.nodes[self.rddid].spillToDisk(self, function() {
				done({pid: self.pid, files: self.files});
			});
		}		
	}
}